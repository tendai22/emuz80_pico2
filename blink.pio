;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

; SET pin 0 should be mapped to your LED GPIO

;
; PIO0:SM0 ... two/one phase clock generator(program clockgen)
;
.program clockgen
.wrap_target
    ; outputs are inverted, so 0 means High, 1 means Low
    set pins, 1 [6]  ; Turn LED on
    set pins, 0   ; Turn LED off
    set pins, 2
    set pins, 3
.wrap             ; Blink forever!

;
; PIO0.SM1 databus control(program databus)
;
; IN/OUT_BASE 16, IN/OUT_COUNT: 8(D0-D7)
; JMP_PIN: N/A(no need to output control pins)
; SET_BASE: 31 (debug pin)
; GPIO: CS: 26, OE: 27
; 12 instructions
.program databus
    pull noblock        ; dummy read
    mov pindirs, null   ; D0-D7 as input
    set pins, 1
.wrap_target
    wait 0 gpio 26
    wait 0 gpio 27
    set pins, 0
    push
    pull                ; wait for databus output data
    out pins, 8         ; put it to D0-D7
    mov pindirs, ~null
    set pins, 1
    wait 1 gpio 27 [7]  ; hold time 50ns (8ns x 7)
    mov pindirs, null
.wrap

% c-sdk {
#include <stdio.h>
#include "hardware/pio.h"
// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin
//extern int my_pio_sm_set_consecutive_pindirs(PIO pio, uint sm, uint pin, uint count, bool is_out);

void clockgen_program_init(PIO pio, uint sm, uint offset, uint pin, uint phase) {

    pio_gpio_init(pio, pin);
    if (phase == 2)
        pio_gpio_init(pio, pin + 1);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, phase, true);
    pio_sm_config c = clockgen_program_get_default_config(offset);
    // set_set_pin_base should have been adjusted by pio->gpiobase
    // so far not so in set_set_pin_base();
    sm_config_set_set_pins(&c, pin, phase);
    // two-phase: (4 instruction loop)
    //  16.0 ... 2.33MHz (420ns/cycle)
    //   9.42 ... 4.0MHz  (250ns/cycle)
    // single clock: (2 instruction loop)
    //  19.0  
    sm_config_set_clkdiv(&c, 5.0);
    pio_sm_init(pio, sm, offset, &c);
}

void databus_program_init(PIO pio, uint sm, uint offset, uint debug_pin) {
   // sm ... 3
   // IN/OUT_BASE: 16(D0), IN/OUT_COUNT: 8(D0-D7)
   // pin ... SET_BASE: as DEBUG_Pin
    pio_gpio_init(pio, debug_pin);
    for (int i = 0; i < 8; ++i)
        pio_gpio_init(pio, 16 + i);
    pio_sm_set_consecutive_pindirs(pio, sm, debug_pin, 1, true);
    pio_sm_config c = databus_program_get_default_config(offset);
    sm_config_set_in_pins(&c, 16);
    sm_config_set_in_pin_count(&c, 8);
    sm_config_set_out_pins(&c, 16, 8);
    sm_config_set_set_pins(&c, debug_pin, 1);
    sm_config_set_clkdiv(&c, 1);         // 1 ... full speed 
    pio_sm_init(pio, sm, offset, &c);
}

%}