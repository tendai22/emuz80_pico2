# async版設計ノート

async版では、PIOプログラムは MREQ,RDなどZ80の制御信号がLowになるのを待たない。常時無限ループで走り続ける。これはハードウェアのエミュレーションと言ってもいいかもしれない。例えば、74HC255双方向バスバッファでRead方向(Picoから見れば出力方向)バッファの制御は OE 信号で行うが、これを、PIOステートマシンのプログラム set_pindirs で行う。wait/pull/pushを使わずに、RD信号だけを見て、その値が0/1でその値をプログラムカウンタに叩き込む。0のときはD0-D7を出力モードに、1のときは入力モードにする。

async版設計の基本的アイディアは、[PicoROM](https://github.com/wickerwaka/PicoROM) から得ている。wait/pull/pushを使わずに単純化した PIO ステートマシン実装と、Arm 機械語でがりがりにチューニングされたメインCPUループによる ROM エミュレーションにより、アクセスタイム 70ns を達成しているのは見事としかいいようがない。

本実装では、「ハードウェアエミュレーション層」は以下のステートマシンから構成される。

* `set_pindir`: D0-D7出力バッファをON/OFFする。
* `data_out`: OSR下位8ビットをD0-D7に出力する
* `data_in`: D0-D7を入力し、ISR下位8ビットに置く。
* `control_in`: RD,WR,MREQ,IORQ の4ピンを読み込みISRに置く。
* `iorq_wait`: IORQがLowになると、WAITをLowにする。メインCPUからのアクションを待ち、到着するとWAITをHighにする。

メインCPUプログラム側では、

* control_in のリードキュー(ISR直結)下位4ビットを解釈し、メモリリード・メモリライト・IOリードライトの3種類の処理に分岐する。
* デフォルトはメモリリード処理、つまり、メモリ配列からアドレスバスの値をインデックスとして１バイト読み出し、data_out ステートマシンの出力キュー(OSR直結)に書き出す。ノンブロック・無限ループで書き出す。
* メモリライト処理は、data_in ステートマシンの入力キュー(ISR直結)の値をアドレスバスインデックスによるメモリ配列要素に書き込む。これもノンブロックで動作する。
* IOリードライト処理は、IORQがLowである場合に起動され、アドレスバスの値とD0-D7の値を見てI/O処理を行い、処理を終えると、iorq_wait ステートマシンの出力キューにデータを書き出す。

IOリードライト処理では、iorq_wait ステートマシンが最初に WAITピンを Low にしてZ80をWAITサイクルに入れているので、メインCPU側では必要な処理をやり切ればよい。やりきると、ステートマシンの入力キューにデータ(どのようなデータでも良い)を書き出すと、ステートマシンは WAITをHighにして次のI/Oサイクル開始を待つ。

これらステートマシンの遅延時間は8nsとか16ns(メモリリード・ライトサイクル)程度となる。メモリアクセスタイムへのインパクトは、メインCPUプログラム側の処理が大部分を占める。よって、この処理を単純化高速化することは最初から意識して進める。

基本的な設計方針は、

* メモリリード/ライトは、ノーウェイトでメインCPUソフトもできるだけasyncで動かす。
* IOリード/ライトは、常に WAIT を発行して Z80 を待たせて、メインCPUはゆっくりと処理する。

パフォーマンスを追及すると、E000/E001HのアクセスのみWAIT待ちを挟むという処理の実装が難しくなる。よって、EMUBASICの魅力(?!)の一つである「メモリマップドI/O」は諦めて、UARTアドレスをI/Oポートアドレス0/1に割り当てる。